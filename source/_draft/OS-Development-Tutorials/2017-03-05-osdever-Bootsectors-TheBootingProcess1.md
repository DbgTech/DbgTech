---
title: 《系统开发》之引导过程1
date: 2017-03-05 11:30:32
tags:
- 操作系统
- 翻译
categories:
- 内核
- 翻译
---

原文地址：[http://www.osdever.net/tutorials/view/the-booting-process](http://www.osdever.net/tutorials/view/the-booting-process)

*By Gregor Brunmar*

### 最好知道的事情... ###

你想要编写你自己的OS，但是没有线索从何处开始？！首先，你需要找到正确的工具。我使用汇编和C代码混合的方式来编写我的MuOS。我使用的工具如下：

汇编：[Nasm](http://www.nasm.us/)

C代码： [Gcc](http://gcc.gnu.org/)（我使用的是[Djgpp](http://www.delorie.com/djgpp/)，但这是因为我在Win32平台编写，尽管这样，但是这工作可以在任何平台上完成）

PC模拟器： [Bochs](http://bochs.sourceforge.net/)（你不想每次验证功能都重启系统，它还是非常必要的。）

现在，有了好的工具。我们的目标是编写32位系统。对于那些认为：'嘿？！不是每一个386+，32位处理器？为什么是低目标的386机器？'：如下是原因。

回到刚刚出现386时，32位是一个全新的功能。因为所有的人花费了大量的$$$在他们的16位的程序上，向后兼容是一个必须的属性。Intel决定让386从16位模式启动，如果操作系统支持32位，它应该手动从16位变为32位模式。每个人都会比较欢迎这种方式，直到今天。计算机依然从16位的兼容模式引导。现在几乎没有16位的操作系统了（Dos是一个16位的系统，依然有用户使用它，所以我不能说没有16位操作系统了）。

当启用了32位模式后，有几个东西完全变了。由此我们想要编写一个32位的操作系统。（一些功能可以在16位模式下访问，但是它要求特殊的技术。）

*访问4GB内存* — 在开始时，处理器处于所谓的实模式（16位）。这将内存访问限制到了大约1MB之内。但是，在保护模式（32位），可访问的内存可以多达4GB。这远比1MB大得多。

*内存保护* — 因为内存保护而叫做保护模式。内存可以被写保护，这样关键区域区段不能够触碰（OS部分或是其他应用程序的数据不能随意修改）。

*多任务* — 处理器内置了对任务钱换的支持。多任务并不是事实上的并行处理，而是通过调度处理时间实现。这个功能保存寄存器状态，并且将下一个任务的寄存器值加载起来来实现（这个可以通过软件爱你实现，但是使用硬件大多数时候更加快）。	

有更多的功能，但是你要是问我最重要的是什么。那就是应该覆盖你需要了解的基础知识。依赖于这些材料，编写一个引导扇区。
<!-- more -->
### 有趣而又危险的部分 ###

创建一个纯文本的文件booting.asm。第一件应该做的是告诉编译器，我们要编译成16位指令。记住，在开始时，计算机运行于实模式（16位）。
```ASM
[BITS 16]
```
然后我们告诉编译器，我们的程序要加载到内存的什么位置。在Nasm中，通过ORG命令来指定位置。你可能会问‘为什么编译器需要知道这些？’。先看一下这一段代码：
	
```ASM
[ORG 0x7C00]
	mov ax, [label]

label:
	dw 0
```
mov指令被汇编成了‘mov ax, 0x7C03’，而不是‘mov ax, 0x0003'。这个对于普通的应用程序来说不是必须的，但是现在我们是在编写引导扇区。选择的值是0x7C00，这个地址是BIOS查找引导扇区的地址。因此这个地方是我们的程序需要保存到的地址。下面添加这一行：

```ASM
[ORG 0x7C00]
```

现在想要在屏幕上写一条消息。简单点，使用是模式下可用的BIOS中断。Int 10h有我们所需要的所有的功能。如果将OEh放入AH寄存器，就是告诉BIOS有一个字符要输出到屏幕上。BIOS获取AL寄存器的ASCII，和BH中的颜色信息，一起打印字符。BL寄存器用于设置一个页面号，但是我们不需要使用这个值。所以只需要设置为0或忽略它即可。那么代码可以这样写：

```ASM
mov ah, 0Eh
mov al, 'A'
mov bh, 0Fh
mov bl, 0
int 10h
```

BH寄存器保存了字符的颜色属性。但是没有解释为什么要在BH寄存器中写入0Fh值，但是它保存了字符的颜色代码。但是这个功能并没有被所有的BIOS支持，那也不妨碍你验证一下（在Bochs中不支持）。颜色值如下列举：

| 值        | 颜色 | 值     | 颜色    |
| -------- | ------: | -----: |   ------:  |
| 00h     | 黑色 | 08h  | 黑灰    |
| 01h     | 蓝色 | 09h  | 明蓝    |
| 02h     | 绿色 | 0Ah  | 明绿    |
| 03h     | 青色 | 0Bh  | 明清    |
| 04h     | 红色 | 0Ch  | 粉红    |
| 05h     | 品红 | 0Dh  |亮品红 |
| 06h     | 棕色 | 0Eh  | 黄色     |
| 07h     | 灰色 | 0Fh  | 白色     |

获取更多关于BIOS中断的信息，Ralf Brown整理了一份完整的列表。可以从这个网址找到它[Here](http://www-2.cs.cmu.edu/afs/cs/user/ralf/pub/WWW/files.html)。

现实了字符A之后仅仅进入挂起状态...，可以通过跳转到一个跳转来实现，不停跳转...

```ASM
hang:
        jmp hang
```

让BIOS能够识别文件为一个有效的i引导扇区，地址0x510处的字必须是55AAh。首先，我们会将文件剩下的部分填充为0，然后再加入这个字节。可以通过如下的方式来添加：

```ASM
times 510 - (% - %%) db
dw AA55h
```

### 组合到一起 ###

现在我们就有了一个引导扇区，但是我们必须先编译一下。要将文件编译为BIOS可以读取的纯二进制文件，我们使用NASM（或Windows上nasmw）带着如下的开关来编译：

```ASM
nasm  -f  bin booting.asm -o booting.bin
```

参数’ -f bin‘ 指定编译为纯二进制。可以选择一个不同的输出名字，但是我选择’ booting.bin‘，但是它是一个逻辑名字。现在我们设置来验证它。将文件拷贝到Bochs的目录，然后将它当作了booting.bin作为软盘使用，然后就完成了。

如下是Bochs的截屏，运行教程中的代码：


[下载](http://www.osdever.net/tutorials/brunmar/bootsect_asm.txt)下载本教程的完整代码。

[下载](http://www.osdever.net/tutorials/brunmar/bochsrc.txt)Bochs的例子配置文件。（BIOS的路径应该需要修改，如果你们使用的是非Win32 1.4.1的其他的发布版本）

进入[下一个教程](http://www.osdever.net/tutorials/view/the-world-of-protected-mode)

评论，改进或是发现了错误，可以给我写邮件：[gregor.brunmar@home.se](gregor.brunmar@home.se)

By Andy @ 2017/03/05 11:30:32 